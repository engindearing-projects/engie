{"id": "py-fibonacci", "category": "algorithms", "language": "python", "prompt": "Write a Python function called fibonacci that takes an integer n and returns the nth Fibonacci number. Use an iterative approach for efficiency.", "requirements": ["def fibonacci", "iterative", "return"], "test_cases": [{"code": "print(fibonacci(0))", "expected": "0"}, {"code": "print(fibonacci(1))", "expected": "1"}, {"code": "print(fibonacci(10))", "expected": "55"}, {"code": "print(fibonacci(20))", "expected": "6765"}], "gold_answer": "```python\ndef fibonacci(n):\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n```"}
{"id": "py-binary-search", "category": "algorithms", "language": "python", "prompt": "Write a Python function called binary_search that takes a sorted list and a target value. Return the index if found, or -1 if not found.", "requirements": ["def binary_search", "return", "while"], "test_cases": [{"code": "print(binary_search([1, 3, 5, 7, 9], 5))", "expected": "2"}, {"code": "print(binary_search([1, 3, 5, 7, 9], 4))", "expected": "-1"}, {"code": "print(binary_search([], 1))", "expected": "-1"}, {"code": "print(binary_search([1], 1))", "expected": "0"}], "gold_answer": "```python\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n```"}
{"id": "py-flatten-list", "category": "data-structures", "language": "python", "prompt": "Write a Python function called flatten that takes a nested list of arbitrary depth and returns a flat list. For example, flatten([1, [2, [3, 4], 5], 6]) should return [1, 2, 3, 4, 5, 6].", "requirements": ["def flatten", "recursive", "return"], "test_cases": [{"code": "print(flatten([1, [2, [3, 4], 5], 6]))", "expected": "[1, 2, 3, 4, 5, 6]"}, {"code": "print(flatten([]))", "expected": "[]"}, {"code": "print(flatten([1, 2, 3]))", "expected": "[1, 2, 3]"}, {"code": "print(flatten([[[[1]]]]))", "expected": "[1]"}], "gold_answer": "```python\ndef flatten(lst):\n    result = []\n    for item in lst:\n        if isinstance(item, list):\n            result.extend(flatten(item))\n        else:\n            result.append(item)\n    return result\n```"}
{"id": "py-lru-cache", "category": "data-structures", "language": "python", "prompt": "Implement an LRU (Least Recently Used) cache in Python as a class called LRUCache. It should support get(key) and put(key, value) operations, both in O(1) time. The constructor takes a capacity parameter.", "requirements": ["class LRUCache", "def get", "def put", "capacity"], "test_cases": [{"code": "c = LRUCache(2)\nc.put(1, 1)\nc.put(2, 2)\nprint(c.get(1))", "expected": "1"}, {"code": "c = LRUCache(2)\nc.put(1, 1)\nc.put(2, 2)\nc.put(3, 3)\nprint(c.get(2))", "expected": "-1"}], "gold_answer": "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n```"}
{"id": "py-merge-sort", "category": "algorithms", "language": "python", "prompt": "Write a Python function called merge_sort that sorts a list of numbers in ascending order using the merge sort algorithm. Return the sorted list.", "requirements": ["def merge_sort", "return", "merge"], "test_cases": [{"code": "print(merge_sort([38, 27, 43, 3, 9, 82, 10]))", "expected": "[3, 9, 10, 27, 38, 43, 82]"}, {"code": "print(merge_sort([]))", "expected": "[]"}, {"code": "print(merge_sort([1]))", "expected": "[1]"}, {"code": "print(merge_sort([5, 4, 3, 2, 1]))", "expected": "[1, 2, 3, 4, 5]"}], "gold_answer": "```python\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n```"}
{"id": "py-validate-email", "category": "string-processing", "language": "python", "prompt": "Write a Python function called is_valid_email that takes a string and returns True if it's a valid email address, False otherwise. Use regex. Should handle common cases like user@domain.com but reject things like @domain.com, user@, user@.com.", "requirements": ["def is_valid_email", "import re", "return"], "test_cases": [{"code": "print(is_valid_email('user@example.com'))", "expected": "True"}, {"code": "print(is_valid_email('user.name+tag@domain.co'))", "expected": "True"}, {"code": "print(is_valid_email('@domain.com'))", "expected": "False"}, {"code": "print(is_valid_email('user@'))", "expected": "False"}, {"code": "print(is_valid_email('plaintext'))", "expected": "False"}], "gold_answer": "```python\nimport re\n\ndef is_valid_email(email):\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))\n```"}
{"id": "py-debounce", "category": "patterns", "language": "python", "prompt": "Write a Python decorator called debounce that takes a wait time in seconds. The decorated function should only execute if it hasn't been called again within the wait period.", "requirements": ["def debounce", "decorator", "timer", "threading"], "gold_answer": "```python\nimport threading\n\ndef debounce(wait):\n    def decorator(fn):\n        timer = None\n        def debounced(*args, **kwargs):\n            nonlocal timer\n            if timer is not None:\n                timer.cancel()\n            timer = threading.Timer(wait, fn, args, kwargs)\n            timer.start()\n        return debounced\n    return decorator\n```"}
{"id": "py-tree-traversal", "category": "data-structures", "language": "python", "prompt": "Write a Python class called TreeNode with val, left, right attributes. Then write three functions: inorder, preorder, and postorder that each take a root TreeNode and return a list of values in the respective traversal order.", "requirements": ["class TreeNode", "def inorder", "def preorder", "def postorder"], "test_cases": [{"code": "root = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\nprint(inorder(root))", "expected": "[4, 2, 5, 1, 3]"}, {"code": "root = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nprint(preorder(root))", "expected": "[1, 2, 3]"}], "gold_answer": "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorder(root):\n    if root is None:\n        return []\n    return inorder(root.left) + [root.val] + inorder(root.right)\n\ndef preorder(root):\n    if root is None:\n        return []\n    return [root.val] + preorder(root.left) + preorder(root.right)\n\ndef postorder(root):\n    if root is None:\n        return []\n    return postorder(root.left) + postorder(root.right) + [root.val]\n```"}
{"id": "py-rate-limiter", "category": "patterns", "language": "python", "prompt": "Write a Python class called RateLimiter that implements a token bucket rate limiter. Constructor takes rate (tokens per second) and capacity (max tokens). It should have an allow() method that returns True if a request is allowed, False otherwise.", "requirements": ["class RateLimiter", "def allow", "token bucket", "time"], "gold_answer": "```python\nimport time\n\nclass RateLimiter:\n    def __init__(self, rate, capacity):\n        self.rate = rate\n        self.capacity = capacity\n        self.tokens = capacity\n        self.last_time = time.time()\n\n    def allow(self):\n        now = time.time()\n        elapsed = now - self.last_time\n        self.last_time = now\n        self.tokens = min(self.capacity, self.tokens + elapsed * self.rate)\n        if self.tokens >= 1:\n            self.tokens -= 1\n            return True\n        return False\n```"}
{"id": "py-csv-parser", "category": "string-processing", "language": "python", "prompt": "Write a Python function called parse_csv that takes a CSV string (with header row) and returns a list of dictionaries. Each dict maps column names to values. Handle quoted fields that may contain commas.", "requirements": ["def parse_csv", "return", "dict"], "test_cases": [{"code": "result = parse_csv('name,age\\nAlice,30\\nBob,25')\nprint(result[0]['name'])", "expected": "Alice"}, {"code": "result = parse_csv('name,age\\nAlice,30\\nBob,25')\nprint(len(result))", "expected": "2"}], "gold_answer": "```python\nimport csv\nimport io\n\ndef parse_csv(text):\n    reader = csv.DictReader(io.StringIO(text))\n    return [dict(row) for row in reader]\n```"}
{"id": "py-retry-decorator", "category": "patterns", "language": "python", "prompt": "Write a Python decorator called retry that takes max_attempts and delay_seconds parameters. It should retry the decorated function on exception, with exponential backoff. After all attempts fail, raise the last exception.", "requirements": ["def retry", "max_attempts", "delay", "exponential"], "gold_answer": "```python\nimport time\nimport functools\n\ndef retry(max_attempts=3, delay_seconds=1):\n    def decorator(fn):\n        @functools.wraps(fn)\n        def wrapper(*args, **kwargs):\n            last_exception = None\n            for attempt in range(max_attempts):\n                try:\n                    return fn(*args, **kwargs)\n                except Exception as e:\n                    last_exception = e\n                    if attempt < max_attempts - 1:\n                        time.sleep(delay_seconds * (2 ** attempt))\n            raise last_exception\n        return wrapper\n    return decorator\n```"}
{"id": "js-debounce", "category": "patterns", "language": "javascript", "prompt": "Write a JavaScript function called debounce that takes a function and a delay in milliseconds. Return a debounced version that delays invoking the function until after the delay ms have elapsed since the last invocation.", "requirements": ["function debounce", "clearTimeout", "setTimeout", "return"], "gold_answer": "```javascript\nfunction debounce(fn, delay) {\n  let timer = null;\n  return function(...args) {\n    clearTimeout(timer);\n    timer = setTimeout(() => fn.apply(this, args), delay);\n  };\n}\n```"}
{"id": "js-deep-clone", "category": "data-structures", "language": "javascript", "prompt": "Write a JavaScript function called deepClone that creates a deep copy of an object. Handle nested objects, arrays, dates, and null values. Do not use JSON.parse/JSON.stringify.", "requirements": ["function deepClone", "recursive", "return", "Array.isArray"], "gold_answer": "```javascript\nfunction deepClone(obj) {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (obj instanceof Date) return new Date(obj.getTime());\n  if (Array.isArray(obj)) return obj.map(item => deepClone(item));\n  const clone = {};\n  for (const key of Object.keys(obj)) {\n    clone[key] = deepClone(obj[key]);\n  }\n  return clone;\n}\n```"}
{"id": "js-promise-all", "category": "async", "language": "javascript", "prompt": "Implement a function called promiseAll that works like Promise.all. It takes an array of promises and returns a promise that resolves with an array of results when all promises resolve, or rejects with the first rejection reason.", "requirements": ["function promiseAll", "return new Promise", "resolve", "reject"], "gold_answer": "```javascript\nfunction promiseAll(promises) {\n  return new Promise((resolve, reject) => {\n    if (promises.length === 0) return resolve([]);\n    const results = new Array(promises.length);\n    let completed = 0;\n    promises.forEach((promise, index) => {\n      Promise.resolve(promise).then(\n        value => {\n          results[index] = value;\n          completed++;\n          if (completed === promises.length) resolve(results);\n        },\n        reject\n      );\n    });\n  });\n}\n```"}
{"id": "js-event-emitter", "category": "patterns", "language": "javascript", "prompt": "Write a JavaScript class called EventEmitter with methods: on(event, callback), off(event, callback), emit(event, ...args), and once(event, callback). Handle multiple listeners per event.", "requirements": ["class EventEmitter", "on(", "off(", "emit(", "once("], "gold_answer": "```javascript\nclass EventEmitter {\n  constructor() {\n    this.listeners = {};\n  }\n\n  on(event, callback) {\n    if (!this.listeners[event]) this.listeners[event] = [];\n    this.listeners[event].push(callback);\n    return this;\n  }\n\n  off(event, callback) {\n    if (!this.listeners[event]) return this;\n    this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);\n    return this;\n  }\n\n  emit(event, ...args) {\n    if (!this.listeners[event]) return false;\n    this.listeners[event].forEach(cb => cb(...args));\n    return true;\n  }\n\n  once(event, callback) {\n    const wrapper = (...args) => {\n      callback(...args);\n      this.off(event, wrapper);\n    };\n    return this.on(event, wrapper);\n  }\n}\n```"}
{"id": "py-graph-bfs", "category": "algorithms", "language": "python", "prompt": "Write a Python function called bfs that takes an adjacency list (dict mapping node to list of neighbors) and a start node. Return a list of nodes in BFS traversal order.", "requirements": ["def bfs", "queue", "visited", "return"], "test_cases": [{"code": "graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['D'], 'D': []}\nprint(bfs(graph, 'A'))", "expected": "['A', 'B', 'C', 'D']"}], "gold_answer": "```python\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    result = []\n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return result\n```"}
{"id": "py-matrix-multiply", "category": "math", "language": "python", "prompt": "Write a Python function called matrix_multiply that takes two 2D lists (matrices) and returns their product as a 2D list. Raise ValueError if dimensions are incompatible.", "requirements": ["def matrix_multiply", "ValueError", "return"], "test_cases": [{"code": "print(matrix_multiply([[1, 2], [3, 4]], [[5, 6], [7, 8]]))", "expected": "[[19, 22], [43, 50]]"}, {"code": "print(matrix_multiply([[1, 0], [0, 1]], [[5, 6], [7, 8]]))", "expected": "[[5, 6], [7, 8]]"}], "gold_answer": "```python\ndef matrix_multiply(a, b):\n    if not a or not b or len(a[0]) != len(b):\n        raise ValueError('Incompatible matrix dimensions')\n    rows_a, cols_a = len(a), len(a[0])\n    cols_b = len(b[0])\n    result = [[0] * cols_b for _ in range(rows_a)]\n    for i in range(rows_a):\n        for j in range(cols_b):\n            for k in range(cols_a):\n                result[i][j] += a[i][k] * b[k][j]\n    return result\n```"}
{"id": "py-trie", "category": "data-structures", "language": "python", "prompt": "Implement a Trie (prefix tree) in Python with insert(word), search(word), and starts_with(prefix) methods. search returns True only for complete words, starts_with returns True for any prefix.", "requirements": ["class Trie", "def insert", "def search", "def starts_with"], "test_cases": [{"code": "t = Trie()\nt.insert('apple')\nprint(t.search('apple'))", "expected": "True"}, {"code": "t = Trie()\nt.insert('apple')\nprint(t.search('app'))", "expected": "False"}, {"code": "t = Trie()\nt.insert('apple')\nprint(t.starts_with('app'))", "expected": "True"}], "gold_answer": "```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n\n    def search(self, word):\n        node = self._find(word)\n        return node is not None and node.is_end\n\n    def starts_with(self, prefix):\n        return self._find(prefix) is not None\n\n    def _find(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return None\n            node = node.children[char]\n        return node\n```"}
{"id": "py-json-flatten", "category": "data-structures", "language": "python", "prompt": "Write a Python function called flatten_json that takes a nested JSON-like dictionary and returns a flat dictionary with dot-notation keys. For example, {'a': {'b': 1, 'c': {'d': 2}}} becomes {'a.b': 1, 'a.c.d': 2}.", "requirements": ["def flatten_json", "return", "dict"], "test_cases": [{"code": "print(flatten_json({'a': {'b': 1, 'c': {'d': 2}}}))", "expected": "{'a.b': 1, 'a.c.d': 2}"}, {"code": "print(flatten_json({'x': 1}))", "expected": "{'x': 1}"}, {"code": "print(flatten_json({}))", "expected": "{}"}], "gold_answer": "```python\ndef flatten_json(obj, prefix='', result=None):\n    if result is None:\n        result = {}\n    for key, value in obj.items():\n        new_key = f'{prefix}.{key}' if prefix else key\n        if isinstance(value, dict):\n            flatten_json(value, new_key, result)\n        else:\n            result[new_key] = value\n    return result\n```"}
{"id": "py-singleton", "category": "patterns", "language": "python", "prompt": "Implement the Singleton design pattern in Python as a decorator called singleton that can be applied to any class. Ensure that only one instance of the decorated class is ever created.", "requirements": ["def singleton", "decorator", "instance"], "test_cases": [{"code": "@singleton\nclass DB:\n    pass\na = DB()\nb = DB()\nprint(a is b)", "expected": "True"}], "gold_answer": "```python\ndef singleton(cls):\n    instances = {}\n    def get_instance(*args, **kwargs):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n    return get_instance\n```"}
{"id": "py-linked-list-reverse", "category": "data-structures", "language": "python", "prompt": "Write a Python class ListNode with val and next attributes. Then write a function called reverse_linked_list that takes the head of a singly linked list and returns the head of the reversed list.", "requirements": ["class ListNode", "def reverse_linked_list", "return"], "test_cases": [{"code": "a = ListNode(1, ListNode(2, ListNode(3)))\nresult = reverse_linked_list(a)\nvals = []\nwhile result:\n    vals.append(result.val)\n    result = result.next\nprint(vals)", "expected": "[3, 2, 1]"}], "gold_answer": "```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_linked_list(head):\n    prev = None\n    current = head\n    while current:\n        next_node = current.next\n        current.next = prev\n        prev = current\n        current = next_node\n    return prev\n```"}
{"id": "py-memoize", "category": "patterns", "language": "python", "prompt": "Write a Python decorator called memoize that caches the results of a function based on its arguments. It should work with any function that takes hashable arguments.", "requirements": ["def memoize", "cache", "decorator", "return"], "test_cases": [{"code": "calls = 0\n@memoize\ndef add(a, b):\n    global calls\n    calls += 1\n    return a + b\nadd(1, 2)\nadd(1, 2)\nprint(calls)", "expected": "1"}, {"code": "@memoize\ndef add(a, b):\n    return a + b\nprint(add(3, 4))", "expected": "7"}], "gold_answer": "```python\ndef memoize(fn):\n    cache = {}\n    def wrapper(*args):\n        if args not in cache:\n            cache[args] = fn(*args)\n        return cache[args]\n    return wrapper\n```"}
{"id": "py-async-gather", "category": "async", "language": "python", "prompt": "Write a Python async function called gather_with_timeout that takes a list of coroutines and a timeout in seconds. Run all coroutines concurrently, return results for those that complete within the timeout, and None for those that don't.", "requirements": ["async def gather_with_timeout", "asyncio", "timeout", "return"], "gold_answer": "```python\nimport asyncio\n\nasync def gather_with_timeout(coros, timeout):\n    async def safe_run(coro):\n        try:\n            return await asyncio.wait_for(coro, timeout=timeout)\n        except asyncio.TimeoutError:\n            return None\n    return await asyncio.gather(*[safe_run(c) for c in coros])\n```"}
{"id": "py-priority-queue", "category": "data-structures", "language": "python", "prompt": "Implement a MinHeap class in Python with methods: push(value), pop() (returns and removes minimum), peek() (returns minimum without removing), and a size property. Do not use heapq.", "requirements": ["class MinHeap", "def push", "def pop", "def peek"], "test_cases": [{"code": "h = MinHeap()\nh.push(5)\nh.push(3)\nh.push(7)\nprint(h.peek())", "expected": "3"}, {"code": "h = MinHeap()\nh.push(5)\nh.push(3)\nh.push(7)\nprint(h.pop())", "expected": "3"}, {"code": "h = MinHeap()\nh.push(5)\nh.push(3)\nh.push(7)\nh.pop()\nprint(h.peek())", "expected": "5"}], "gold_answer": "```python\nclass MinHeap:\n    def __init__(self):\n        self.heap = []\n\n    @property\n    def size(self):\n        return len(self.heap)\n\n    def push(self, value):\n        self.heap.append(value)\n        self._sift_up(len(self.heap) - 1)\n\n    def pop(self):\n        if not self.heap:\n            raise IndexError('pop from empty heap')\n        self._swap(0, len(self.heap) - 1)\n        value = self.heap.pop()\n        if self.heap:\n            self._sift_down(0)\n        return value\n\n    def peek(self):\n        if not self.heap:\n            raise IndexError('peek from empty heap')\n        return self.heap[0]\n\n    def _sift_up(self, i):\n        while i > 0:\n            parent = (i - 1) // 2\n            if self.heap[i] < self.heap[parent]:\n                self._swap(i, parent)\n                i = parent\n            else:\n                break\n\n    def _sift_down(self, i):\n        n = len(self.heap)\n        while True:\n            smallest = i\n            left = 2 * i + 1\n            right = 2 * i + 2\n            if left < n and self.heap[left] < self.heap[smallest]:\n                smallest = left\n            if right < n and self.heap[right] < self.heap[smallest]:\n                smallest = right\n            if smallest != i:\n                self._swap(i, smallest)\n                i = smallest\n            else:\n                break\n\n    def _swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\n```"}
{"id": "js-throttle", "category": "patterns", "language": "javascript", "prompt": "Write a JavaScript function called throttle that takes a function and a limit in milliseconds. The throttled function should only execute at most once per limit period.", "requirements": ["function throttle", "setTimeout", "return"], "gold_answer": "```javascript\nfunction throttle(fn, limit) {\n  let lastCall = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastCall >= limit) {\n      lastCall = now;\n      return fn.apply(this, args);\n    }\n  };\n}\n```"}
{"id": "js-curry", "category": "patterns", "language": "javascript", "prompt": "Write a JavaScript function called curry that takes a function and returns a curried version. The curried function should accept arguments one at a time or in groups until all arguments are provided, then execute the original function.", "requirements": ["function curry", "return", "length"], "gold_answer": "```javascript\nfunction curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn.apply(this, args);\n    }\n    return function(...more) {\n      return curried.apply(this, args.concat(more));\n    };\n  };\n}\n```"}
{"id": "py-dijkstra", "category": "algorithms", "language": "python", "prompt": "Write a Python function called dijkstra that takes a weighted graph (dict mapping node to list of (neighbor, weight) tuples) and a start node. Return a dict mapping each node to its shortest distance from start.", "requirements": ["def dijkstra", "heap", "distances", "return"], "test_cases": [{"code": "graph = {'A': [('B', 1), ('C', 4)], 'B': [('C', 2), ('D', 5)], 'C': [('D', 1)], 'D': []}\nresult = dijkstra(graph, 'A')\nprint(result['D'])", "expected": "4"}], "gold_answer": "```python\nimport heapq\n\ndef dijkstra(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    heap = [(0, start)]\n    while heap:\n        dist, node = heapq.heappop(heap)\n        if dist > distances[node]:\n            continue\n        for neighbor, weight in graph.get(node, []):\n            new_dist = dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(heap, (new_dist, neighbor))\n    return distances\n```"}
{"id": "py-observer-pattern", "category": "patterns", "language": "python", "prompt": "Implement the Observer design pattern in Python. Create a Subject class with attach(observer), detach(observer), and notify(event) methods. Create an Observer base class with an update(event) method.", "requirements": ["class Subject", "class Observer", "def attach", "def detach", "def notify"], "gold_answer": "```python\nclass Observer:\n    def update(self, event):\n        raise NotImplementedError\n\nclass Subject:\n    def __init__(self):\n        self._observers = []\n\n    def attach(self, observer):\n        self._observers.append(observer)\n\n    def detach(self, observer):\n        self._observers.remove(observer)\n\n    def notify(self, event):\n        for observer in self._observers:\n            observer.update(event)\n```"}
{"id": "py-pipeline", "category": "patterns", "language": "python", "prompt": "Write a Python function called pipeline that takes a list of functions and returns a new function that pipes the output of each function into the next. pipeline([f, g, h])(x) should equal h(g(f(x))).", "requirements": ["def pipeline", "return", "reduce"], "test_cases": [{"code": "p = pipeline([lambda x: x + 1, lambda x: x * 2, lambda x: x - 3])\nprint(p(5))", "expected": "9"}], "gold_answer": "```python\nfrom functools import reduce\n\ndef pipeline(functions):\n    def execute(value):\n        return reduce(lambda acc, fn: fn(acc), functions, value)\n    return execute\n```"}
{"id": "py-topological-sort", "category": "algorithms", "language": "python", "prompt": "Write a Python function called topological_sort that takes a directed acyclic graph (dict mapping node to list of dependencies) and returns a valid topological ordering as a list.", "requirements": ["def topological_sort", "visited", "return"], "test_cases": [{"code": "graph = {'a': [], 'b': ['a'], 'c': ['a', 'b'], 'd': ['c']}\nresult = topological_sort(graph)\nprint(result.index('a') < result.index('b') < result.index('c') < result.index('d'))", "expected": "True"}], "gold_answer": "```python\ndef topological_sort(graph):\n    visited = set()\n    result = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        visited.add(node)\n        for dep in graph.get(node, []):\n            dfs(dep)\n        result.append(node)\n\n    for node in graph:\n        dfs(node)\n    return result\n```"}
{"id": "py-context-manager", "category": "patterns", "language": "python", "prompt": "Write a Python context manager class called Timer that measures the execution time of a code block. It should store the elapsed time in seconds as a .elapsed attribute after the block completes.", "requirements": ["class Timer", "__enter__", "__exit__", "elapsed"], "test_cases": [{"code": "import time\nwith Timer() as t:\n    time.sleep(0.1)\nprint(t.elapsed >= 0.1)", "expected": "True"}], "gold_answer": "```python\nimport time\n\nclass Timer:\n    def __init__(self):\n        self.elapsed = 0\n\n    def __enter__(self):\n        self.start = time.time()\n        return self\n\n    def __exit__(self, *args):\n        self.elapsed = time.time() - self.start\n```"}
